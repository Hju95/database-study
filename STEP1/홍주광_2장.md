#### 2장 SQL 튜닝 용어를 직관적으로 이해하기

### 2.1 물리 엔진과 오브젝트 용어

2.1.1 DB 엔진 용어

![image](https://github.com/Hju95/database-study/assets/59231743/927c54ed-13eb-40ab-8f5d-a36a0b21425f)

**MySQL/MariaDB 의 전체적인 구조**

-   사용자는 DB에서 원하는 데이터를 가져오고자 SQL 문을 실행
-   실행된 SQL 문은 MySQL 엔진에서 문법 에러가 있는지, DB에 존재하는 테이블 대상으로 SQL 문을 작성했는지와 같은 세부 사항을 다양한 문법 및 구문으로 검사 -> 파싱 작업을 하는 파서 역할
-   사용자가 요청한 데이터를 빠르고 효율적으로 찾아가는 전략적 계획 수립 -> 옵티마이저 역할
-   이 계획을 토대로 스토리지 엔진에 위치한 데이터까지 찾아간 뒤 해당 데이터를 MySQL 엔진으로 전달
-   MySQL 엔진은 전달된 데이터에서 불필요한 부분을 필터링(제거, 변경)하고 필요한 연산을 수행한 뒤 사용자에게 최종 결과를 알림

**스토리지 엔진**

\- (InnoDB, MyISAM, Memory 등) 스토리지 엔진은 사용자가 요청한 SQL 문을 토대로 DB에 저장된 디스크나 메모리에서 필요한 데이터를 가져오는 역할을 수행함

\- 이후 해당 데이터를 MySQL 엔진으로 보냄

InnoDB : 온라인상의 트랜잭션 발생으로 데이터를 처리하는 OLTP(online transaction processing) 환경에서 주로 사용

MyISAM : 대량의 쓰기 트랜잭션 발생에 사용

Memory : 메모리 데이터를 로드하여 빠르게 읽는 효과를 내기 위해 사용

**MySQL 엔진** 

\- 사용자가 요청한 SQL 문을 넘겨받은 뒤 SQL 문법 검사와 적절한 오브젝트 활용 검사를 하고, SQL 문을 최소 단위로 분리하여 원하는 데이터를 빠르게 찾는 경로를 모색하는 역할을 수행\- 이후 스토리지 엔진으로부터 전달받은 데이터 대상으로 불필요한 데이터는 제거하거나 가공 및 연산하는 역할\- SQL 문의 시작 및 마무리 단계에 MySQL 엔진이 관여하며, 스토리지 엔진으로부터 필요한 데이터만을 가져오는 핵심 역할을 담당

2.1.2 SQL 프로세스 용어

![image](https://github.com/Hju95/database-study/assets/59231743/09456b6d-4980-4345-8820-9722a69f8db0)

**SQL 실행 과정**

-   사용자가 SQL 문을 수행
-   파서는 MySQL이 이해할 수 있는 최소 단위로 구성요소를 분리하고 해당 구성요소를 트리로 만듦
-   트리를 만드는 과정에서 문법 오류가 있는지 검토
-   트리의 최소 단위는 >, <, = 등의 기호나 SQL 키워드를 분리
-   (만약 트리에 허용되지 않는 문법이 포함된다면 에러 발생과 동시에 실행 종료)
-   이후 전처리기는 생성된 트리 결과를 토대로, 이미 만들어진 테이블이나 뷰 등으로 구성되지는 않는지, 존재하지 않는 열을 포함하지는 않는지, 조회 권한이 없는 테이블을 조회하는지 등 유효성 검증
-   (만약 유효하지 않는 오브젝트가 있거나 권한이 없는 오브젝트를 호출하면 바로 에러를 발생하고 사용자에게 표시)
-   옵티마이저는 트리를 구성하는 오브젝트의 데이터를 효율적으로 가져오기 위해 시간은 적게 소요되면서도 비용 효율적인 경로로 데이터를 검색하는 방법에 관한 실행 계획 수립
-   엔진 실행기는 이전에 수립된 실행 계획으로 스토리지 엔진을 호출해 필요한 데이터를 가져옴
-   이후 엔진 실행기는 스토리지 엔진을 통해서 가져온 데이터 중 불필요한 데이터를 필터링하여 사용자가 원하는 결과를 전달

**파서**

\- 파서는 MySQL 엔진에 포함되는 오브젝트

\- 사용자가 요청한 SQL 문을 쪼개 최소 단위로 분리하고 트리를 만듦

\- 문법 검사를 수행

**전처리기**

\- 전처리기는 MySQL 엔진에 해당하는 오브젝트

파서에서 생성한 트리를 토대로 SQL 문에 구조적인 문제가 없는지 파악

SQL 문에 작성된 테이블, 열, 함수,뷰와 같은 오브젝트가 실질적으로 이미 생성된 오브젝트인지, 접근 권한은 부여되어 있는지 확인하는 역할

**옵티마이저**

\- 옵티마이저는 MySQL 의 핵심 엔진 중 하나

\- 전달된 파서 트리를 토대로 필요하지 않은 조건은 제거하거나 연산 과정을 단순화

\- 어떤 순서로 테이블에 접근할지, 인덱스를 사용할지, 사용한다면 어떤 인덱스를 사용할 지, 정렬할 때 인덱스를 사용할지 아니면 임시 테이블을 사용할지와 같은 실행 계획을 수립

\- 실행 계획으로 도출할 수 있는 경우의 수가 지나치게 많을 때는 실행 계획을 수립하고 비용을 산정하여 최적의 실행 계획을 선택하기까지 시간이 오래 걸리는 만큼 모든 실행 계획을 판단하지는 않음  
\-> 옵티마이저가 선택한 최적의 실행 계획이 최상의 실행 계획이 아닐 가능성을 시사함

\- 실행 계획을 수립하는 작업 자체만으로도 사용자의 대기 시간과 하드웨어 리소스를 점유

**엔진 실행기**

 -엔진 실행기는 MySQL 엔진과 스토리지 엔진 영역 모두 걸치는 오브젝트

\- 옵티마이저에서 수립한 실행 계획을 참고하여 스토리지 엔진에서 데이터를 가져옴

\- 이후 MySQL 엔진에서 읽어온 데이터를 정렬하거나 조인, 불필요한 데이터는 필터링 처리하는 추가 작업 진행

\-> MySQL 엔진을 부하를 줄이려면 스토리지 엔진에서 가져오는 데이터양을 줄이는게 매우 중요

#### 2.1.3 DB 오브젝트 용어

![image](https://github.com/Hju95/database-study/assets/59231743/6094970f-1fbf-4706-94b7-0ac29d160206)

**테이블**

\- 테이블은 데이터를 저장하는 오브젝트로 행과 열의 정보를 담음

\- MySQL은 2차원 배열 형태로 테이블

**로우(행)**

\- 로우는 행에 해당하는 용어로, 테이블에서 동일한 구조의 데이터 항목들의 집합을 가리킴

\- 행 수가 많아지면 데이터에 접근하는 과정에서 시간이 오래 소요될 가능성이 높음

\-> 이 때 파티셔닝 기법으로 SQL 문의 성능 향상을 검토해 볼 수 있음

**컬럼(열)**

\- 컬럼은 열에 해당하는 용어

\- 사전에 정의한 데이터 유형으로 데이터값을 저장하며, 열별로 다른 데이터 유형을 가질 수 있음

**기본 키**

\- 기본 키(PK)는 특정 행을 대포하는 열을 가리키는 용어로 주 키라고도 함

\- 상황에 따라 2개 이상의 열을 조합해 기본 키를 구성할 수도 있음

\- 인덱스 역할도 수행하므로 기본 키를 활용하여 인덱싱할 수 있음

\- MySQL/MariaDB에서 기본 키는 클러스터형 인덱스로 작동

\-> 이는 기본 키의 구성 열 순서를 기준으로 물리적인 스토리지에 데이터가 쌓인다는 뜻

\-> 즉, 비슷한 기본 키 값들이 근거리에 적재되므로 기본 키를 활용하여 인덱스 스캔을 수행하면 테이블 데이터에 더 빠르게 접근할 수 있음

-----
> TIP 인덱스의 주의사항

기본 키와 똑같은 인덱스를 생성하면 인덱스가 저장되는 물리적 공간이 낭비되는 한편 데이터의 삽입/삭제/수정에 따른 인덱스 정렬의 오버헤드가 발생

-----

**외래 키**

\- 외래 키(FK)는 외부에 있는 테이블을 항상 참조하면서, 외부 테이블의 데이터가 변경되면 함께 영향을 받는 관계를 설정하는 키

**인덱스**

\- 인덱스는 데이터베이스에서 키값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는, 키 기준으로 정렬된 오브젝트

ex) 책의 인덱스

| 고유 인덱스 |

\- 인덱스를 구성하는 열들의 데이터가 유일하다는 의미

\- 차례로 정렬되는 인덱스 열의 데이터는 서로 중복되지 않고 유일성을 유지

ex) 연락처

| 비고유 인덱스 |

\- 고유 인덱스에서 데이터의 유일한 속성만 제외한 키

\- 데이터가 신규 입력되어 인덱스가 재정렬되더라도 인덱스 열의 중복 체크를 거치지 않고 단순한 정렬 작업을 수행

ex) 이름

-----
> TIP 기본 키와 고유 인덱스의 차이점

기본 키와 고유 인덱스 모두 데이터의 유일성을 보장해야 하는 특성과 효율적인 데이터 접근을 위한 인덱스로의 수단으로 사용되기 때문에 혼란스러움

기본 키에는 NULL을 입력할 수 없지만 고유 인덱스에는 얼마든지 입력할 수 있음

-----
**뷰**

\- 뷰는 가상테이블이라고도 하며 물리적으로 잡히지 않는 유령과 같은 오브젝트

\- 외부에 직접적으로 공개하지 않고도 제한된 정보만을 제공할 수 있음

-----
> TIP 뷰를 사용하는 이유

뷰를 사용하는 이유는 일부 데이터에 대해서만 데이터를 공개하고, 노출에 민감한 데이터에 대해서는 제약을 설정할 수 있는 보안성 때문

여러 개의 테이블을 병합(join) 해서 활용할 때는 성능을 고려한 최적화된 뷰를 생성함으로써 일관된 성능을 제공할 수 있음

-----
### 2.2 논리적인 SQL 개념 용어

#### 2.2.1 서브쿼리 위치에 따른  SQL 용어

![image](https://github.com/Hju95/database-study/assets/59231743/d14dd6bc-3ec5-4d01-a450-d75d75a396ad)

**서브 쿼리**

쿼리 안의 보조쿼리를 가리키는 용어

SELECT 절 : 스칼라 서브쿼리

FROM 절 : 인라인 뷰

WHERE 절 : 중첩 서브쿼리

**스칼라 서브쿼리**

\- 메인쿼리의 SELECT 절에 있는 또 다른 SELECT 절

\- 메인쿼리의 SELECT 절에는 최종 출력하려는 열들이 나열되므로, 출력 데이터 1건과 스칼라 서브쿼리의 결과 건수가 일치해야 함

\- 즉, 스칼라 서브쿼리의 결과값은 1행 1열의 구조로 출력되어야함

\- 보통 스칼라 서브쿼리는 출력되는 데이터 건수가 1건이어야 하므로 집계함수(max, min avg, sum, count 등)가 자주 쓰임

```
SELECT 이름,
		(SELECT COUNT(*)
        	FROM 학생 AS 학생2
           WHERE 학생2.이름 = 학생1.이름) 카운트
    FROM 학생 AS 학생1;
```

**인라인 뷰**

\- 메인쿼리의 FROM 절에 있는 또 다른 SELECT 절

\- FROM 절 내부에서 일시적으로 뷰를 생성하는 방식이라서 인라인 뷰라고 불림

\- 인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성하여 활용

```
SELECT 학생2.학번, 학생2.이름
  FROM (SELECT *
  		  FROM 학생
         WHERE 성별 = '남') 학생2;
```

**중첩 서브쿼리**

\- 메인쿼리의 WHERE 절에 있는 또 다른 SELECT 절

\- WHERE 절에서 단순한 값을 비교 연산하는 대신, 서브쿼리를 추가하여 비교 연산하기 위해 중첩 서브쿼리를 사용

\- 보통 비교 연산자 (=, <, >, <=, >=, <>, !=)를 비롯해 IN, EXISTS, NOT IN, NOT EXISTS 문을 많이 사용

```
SELECT *
  FROM 학생
 WHERE 학번 = (SELECT MAX(학번)
 				 FROM 학생)
```

#### 2.2.2 메인쿼리와의 관계성에 따른 SQL 용어

**비상관 서브쿼리**

\- 메인쿼리와 서브쿼리 간에 관계성이 없음을 의미

\- 서브쿼리가 독자적으로 실행된 뒤 메인쿼리에게 그 결과를 던져주는 형태

\- 서브쿼리 실행 -> 메인쿼리 실행의 순서

```
SELECT *
  FROM 학생
 WHERE 학번 IN (SELECT 학번
 				  FROM 학생
                 WHERE 성별 = '남')
```

**상관 서브쿼리**

\- 메인쿼리와 서브쿼리 간에 관계성이 있음을 의미

\- SELECT 절에 작성하는 스칼라 서브쿼리와 WHERE 절에 작성하는 중첩 서브쿼리일 때 발생

\- 메인쿼리 실행(학생.학번 데이터 가져오기) -> 서브쿼리 실행(지도교수.학번 = 학생.학번) -> 다시 메인쿼리 실행한 뒤 결과 출력(SELECT \* FROM 학생~)

```
SELECT *
  FROM 학생
 WHERE 학번 IN (SELECT 학번
 				  FROM 지도교수
                 WHERE 성별 = 지도교수.학번 - 학생.학번)
```

#### 2.2.3 반환 결과에 따른 SQL 용어

**단일행 서브쿼리**

\- 서브쿼리 결과가 1건의 행으로 반환되는 쿼리

\- 스칼라 서브쿼리와 동일하다고 볼 수 있음

```
SELECT ...
  FROM ...
 WHERE 학번 = (SELECT MAX(학번) 
 				 FROM 학생)
```

**다중행 서브쿼리**

\- 서브쿼리 결과가 여러 건의 행으로 반환되는 쿼리

```
SELECT ...
  FROM ...
 WHERE 학번 IN (SELECT MAX(학번) 
 				 FROM 학생
                GROUP BY 전공코드)
```

**다중열 서브쿼리**

\- 서브쿼리 결과가 여러 개의 열과 행으로 반환

```
SELECT ...
  FROM ...
 WHERE (이름, 전공코드) 
 		IN (SELECT 이름, 전공코드 
 			  FROM 학생
             WHERE 이름 LIKE '김%')
```

#### 2.2.4 조인 연산방식 용어

![image](https://github.com/Hju95/database-study/assets/59231743/c1d4957b-759c-4f98-8ed6-69af8e746371)


**내부 조인(INNER JOIN)**

\- 교집합에 해당하는 방식

\- 양쪽에 모두 존재하는 데이터만 반환

```
-- 명시적 조인
SELECT 학생.학번, 학생.이름, 지도교수.교수명
  FROM 학생
  JOIN 지도교수
  	ON 학생.학번 = 지도교수.학번
    
-- 암시적 조인
SELECT 학생.학번, 학생.이름, 지도교수.교수명
  FROM 학생, 지도교수
 WHERE 학생.학번 = 지도교수.학번
```

**왼쪽 외부 조인(LEFT OUTER JOIN)**

\- 왼쪽 테이블(먼저 작성된 테이블) 기준으로 오른쪽 테이블(나중에 작성된 테이블)과 조인을 수행

\- 조인 조건과 일치하지 않더라도 왼쪽 테이블의 결과는 최종 결과에 포함

```
SELECT 학생.학번, 학생.이름, 지도교수.교수명
  FROM 학생
  LEFT OUTER JOIN 지도교수
  			   ON 학생.학번 = 지도교수.학번
```

**오른쪽 외부 조인(RIGHT OUTER JOIN)**

\- 오른쪽 테이블(나중에 작성된 테이블) 기준으로 왼쪽 테이블(먼저 작성된 테이블)과 조인

\- 조인 조건과 일치하지 않더라도 오른쪽 테이블의 결과는 최종 결과에 포함

```
SELECT 지도교수.학번, 학생.이름, 지도교수.교수명
  FROM 학생
  LIGHT OUTER JOIN 지도교수
  			   ON 학생.학번 = 지도교수.학번
```

-----
> TIP 전체 외부 조인의 지원 여부

전체 외부 조인은 왼쪽 외부 조인과 오른쪽 외부 조인이 통합된 조인방식으로, MySQL 과 MariaDB에서 지원하지 않음

-----
**교차 조인(CROSS JOIN)**

\- 데카르트 곱(cartesian product) 이라고 하는 곱집합 개념

\- 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 찾아 반환

\- 조인 연산과정의 시간적, 공간적 리소스 점유 측면에서 오버헤드가 발생할 수 있음

![image](https://github.com/Hju95/database-study/assets/59231743/ae149a40-731c-4980-9a01-dc54b4da5538)

```
-- 명시적 조인
SELECT 학생.학번, 학생.이름, 
	   지도교수.학번, 지도교수.교수명
  FROM 학생
 CROSS JOIN 지도교수
 
 -- 암시적 조인
 SELECT 학생.학번, 학생.이름, 
	   지도교수.학번, 지도교수.교수명
  FROM 학생, 지도교수
```

**자연 조인(NATURAL JOIN)**

\- 2개 테이블에 동일한 열명이 있을 때 조인 조건절을 따로 작성하지 않아도 자동으로 조인을 수행해주는 방식

\- 조인이 제대로 성사되면 내부 조인과 동일한 결과 출력

```
SELECT 학생.*, 지도교수.*
  FROM 학생
 NATURAL JOIN 지도교수
```

\- 동일한 열명이 없다면 발생 가능한 경우의 수를 모두 조합하는 교차 조인으로 수행

\- 만약 SQL 문에 ON 학생.학번 = 지도교수.학번 과 같은 구문을 입력하면 에러 발생

#### 2.2.5 조인 알고리즘 용어

**드라이빙 테이블과 드리븐 테이블**

\- 다수의 테이블에서 조인을 수행할 때는 동시에 여러 개의 테이블에 접근할 수 없는 만큼 접근하는 우선순위를 정함

\- 이때 테이블에 접근하는 선후 관계에 따라 드라이빙 테이블과 드리븐 테이블이라는 용어로 구분

![image](https://github.com/Hju95/database-study/assets/59231743/8c49511a-9cf2-4c80-af9e-924ac6074853)

학생 테이블 - 드라이븡 테이블

비상연락망 테이블 - 드리븐 테이블

\- 가능하면 적은 결과가 반환될 것으로 예상되는 드라이빙 테이블을 선정하고, 조인 조건절의 열이 인덱스로 설정되도록 구성해야함

**중첩 루프 조인(NESTED LOOP JOIN)**

\- NL 조인이라고 불림

\- 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 최종적으로 양쪽 테  
이블에 공통된 데이터를 출력

-   기본 키와 인덱스가 없는 두 테이블이 존재하는 상황

```
SELECT 학생.학번, 학생.이름, 
	   비상연락망.관계, 비상연락망.연락처
  FROM 학생
  JOIN 비상연락망
	ON 학생.학번 = 비상연락망.학번
 WHERE 학생.학번 IN (1, 100)
```

![image](https://github.com/Hju95/database-study/assets/59231743/a85909d6-7fff-4733-b8cf-cb969d71f517)

![image](https://github.com/Hju95/database-study/assets/59231743/4a5678db-a9db-4dd5-9dc4-7ae257bb6a95)

(그림은 정렬되어 있으나 보통은 테이블 데이터가 뒤엉켜 있을 가능성이 높다)

-   학번 1 데이터(100 + 1,000) 와 학번 100 데이터(100 + 1,000) 를 조회하기 위해 대력 2,200 건의 데이터에 접근함

-   학생 테이블에 학번 열로 인덱스가 생성되어 있고, 비상 연락망 테이블에도 학번 열로 인덱스가 생성되어 있는 환경

![image](https://github.com/Hju95/database-study/assets/59231743/e7564dc8-b0da-4768-b958-f3f31b2277d9)

-   학번 1 데이터(1+2) 와 학번 100 데이터(1+1) 를 찾기 위해 총 6건의 데이터에 접근함

\- 인덱스는 인덱스로 정의된 열 기준으로 순차 정렬되지만, 인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 랜덤 액세스가 발생함

\-> 랜덤 액세스를 줄일 수 있도록 데이터 액세스 범위를 좁히는 방향으로 인덱스를 설계하고 조건절을 작성해야함

\- 단, 랜덤 액세스를 유발하는 인덱스는 기본 키가 아닌 비고유 인덱스일 경우에 해당

\- 기본 키는 클러스터형 인덱스이므로 기본 키의 순서대로 테이블의 데이터가 적재되어 있어 조회 효율이 매우 높음

**블록 중첩 루프 조인(BLOCK NESTED LOOP JOIN)**

\- BNL 조인이라고 불림

\- 학생 테이블이 드라이빙 테이블이고 비상연락망 테이블은 인덱스가 없다고 가정하고 중첩 루프 조인을 한다면 드리븐 테이블에 대해 매번 전체 데이터를 비효율적으로 검색해야함 -> 블록 중첩 루프 조인의 탄생 배경

\- 드라이빙 테이블에 대해 조인 버퍼라는 개념을 도입

![image](https://github.com/Hju95/database-study/assets/59231743/81f2fddf-3465-4f55-a1bf-20a49156d671)

1.  드라이빙 테이블인 학생 테이블에서 학번 1과 100에 해당하는 데이터를 검색
2.  검색된 데이터를 조인 버퍼에 가득 채워질 때까지 적재(그림상 0번)
3.  조인 버퍼와 비상연락망 테이블을 비교 (즉, 0번인 조인 버퍼와 2번인 데이터를 조인하고, 다시 0번인 조인 버퍼와 3번인 데이터를 조인하는 식으로 반복) - 데이터 풀 스캔

이 과정은 비상연락망 테이블의 테이블 풀 스캔을 줄이는 게 목적으로, 성능 저하를 개선하는 조인 알고리즘 방식

**배치 키 액세스 조인(BATCHED KEY ACCESS JOIN)**

\- BKA 조인이라고 불림

\- 중첩 루프 조인 방식의 랜덤 액세스 문제를 해결하고자 접근할 데이터를 미리 예상하고 가져  
오는 데 착안된 조인 알고리즘

\- 블록 중첩 루프 조인에서 활용한 드라이빙 테이블의 조인 버퍼 개념을그대로 사용

\- 드리븐 테이블에 필요한 데이터를 미리 예측하고 정렬된 상태로 담는 랜덤 버퍼의 개념을 도입

\- 드리븐 테이블의 데이터를 예측하고 정렬된 상태로 버퍼에 적재하는 기능을 다중 범위 읽기(multi range read , MMR) 라고 함

\- 즉, 미리 예측된 데이터를 가져와 정렬된 상태에서 랜덤 버퍼에 담기 때문에, 드리븐테이블에 대해 랜덤 액세스가 아닌 시퀀셜 액세스를 수행하는 방식

![image](https://github.com/Hju95/database-study/assets/59231743/cfafd351-e12d-41cb-8ddd-d5ff972fa893)

1.  드라이빙 테이블에서 필요한 데이터를 추출하여 조인버퍼에 적재 (학번 1과 100인 데이터 저장)
2.  드리븐 테이블의 인덱스 기반으로 필요한 데이터를 예측하여 랜덤 버퍼에 적재하고 학번 1과 100 데이터를 랜덤 버퍼인 메모리상에 상주시킴
3.  학생.학번 = 비상연락방.학번에 대한 조인 조건절로 비교
4.  동일한 데이터가 있다고 판단되면 드리븐 테이블의 데이터에 접근하고 결과를 조인하여 반환

**해시 조인(HASH JOIN)**

\- 해시 조인(hash join)은 MYSQL 8.0.18 버전부터 지원되는 조인 방식

\- 선후 관계를 두고 조인을 수행하는 중첩 루프 조인과 달리 조인에 참여하는 각 테이블의데이터를 내부적으로 해시값을 만들어 내부 조인을 수행

\- 해시값으로 내부 조인을 수행한 결과는 조인 버퍼에 저장되므로 조인 열의 인덱스를 필수로 요구하지 않음

![image](https://github.com/Hju95/database-study/assets/59231743/588b96ab-d1a8-41bc-b0ba-b5b15cc430cf)

### 2.3 개념적인 튜닝 용어

#### 2.3.1 기초 용어

**오브젝트 스캔 유형**

테이블 스캔과 인덱스 스캔으로 구분

-   테이블 스캔 :인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근하는 유형  
    \- 테이블 풀스 캔 방식
-   인덱스 스캔 : 인덱스로 테이블 데이터를 찾아가는 유형  
    \- 인덱스 범위 스캔, 인덱스 풀 스캔, 인덱스 고유 스캔, 인덱스 루스 스캔, 인덱스 병합 스캔 방식

| 테이블 풀 스캔 |

\- 인덱스를 거치지 않고 테이블로 바로 직행하여 처음부터 끝까지 데이터를 훑어보는 방식

\- 인덱스 없이 사용하는 유일한 방식

![image](https://github.com/Hju95/database-study/assets/59231743/3e23a454-61c8-436a-81a5-9c4bef0fafbf)

| 인덱스 범위 스캔 |

\- 인덱스 범위 기준으로 스캔한 뒤 스캔 결과를 토대로 테이블의 데이터를 찾아가는 방식

\- 좁은 범위를 스캔할 때는 성능적으로 매우 효율적인 방식이지만 넓은 범위를 스캔할 때는 비효율적인 방식

![image](https://github.com/Hju95/database-study/assets/59231743/be2cd770-3ded-4d7f-8212-b4391352338a)

| 인덱스 풀 스캔 |

\- 인덱스를 처음부터 끝까지 수행하는 방식

\- 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 SQL문에서 수행됨

\- 인덱스는 테이블보다 상대적으로 적은 양을 차지하므로 인덱스 풀 스캔 방식이 테이블풀 스캔보다 성능상 유리

![image](https://github.com/Hju95/database-study/assets/59231743/73cffe55-9e98-47aa-a381-3e1ae775e676)

| 인덱스 고유 스캔 |

\- 기본키나 고유 인덱스로 테이블에 접근하는 방식  
\- 인덱스를 사용하는 스캔 방식 중 가장 효율적인 스캔 방법  
\- WHERE절에 = 조건으로 작성하며, 해당 조인 열이 기본키 또는 고유 인덱스의 선두 열로 설정되었을때 활용

![image](https://github.com/Hju95/database-study/assets/59231743/d607b24c-56d8-4660-ac06-a7d70b48364c)

| 인덱스 루스 스캔 |

\- 인덱스의 필요 부분만 골라 스캔하는 방식

\- 인덱스 범위 스캔처럼 넓은 범위에 접근하지 않고 WHERE 절 조건문 기준으로 필요한 데이터와 필요하지 않은 데이터를 구분한 뒤 불필요한 인덱스 키는 무시함

\- 보통 GROUP BY 구문이나 MAX(), MIN() 함수가 포함되면 작동  
\-> 이미 오름차순으로 정렬된 인덱스에서 최댓값이나 최솟값이 필요한 경우 해당

![image](https://github.com/Hju95/database-study/assets/59231743/69c37614-52fe-44a8-9c25-f4ca534acac8)

| 인덱스 병합 스캔 |

\- 테이블 내에 생성된 인덱스들을 통합해서 스캔하는 방식

\- WHERE 문 조건절의 열들이 서로 다른 인덱스로 존재하면 옵티마이저가 해당하는 인덱스를 가져와 모두 활용하는 방식을 취함

\- 통합하는 방법으로는 결합(union), 교차(intersection) 방식이 있으며 이들 방식은 모두실행 계획으로 출력

\- 물리적으로 존재하는 개별 인덱스를 각각 수행하므로 인덱스에 접근하는 시간이 몇 배로 걸림

![image](https://github.com/Hju95/database-study/assets/59231743/7ec52485-8804-46ae-9e22-4fb3c74a6cc2)

**디스크 접근 방식**

| 시퀀셜 액세스 |

\- 물리적으로 인접한 페이지를 차례대로 읽는 순차 접근 방식

\- 보통 테이블 풀 스캔에서 활용

\- 데이터를 찾고자 이동하는 디스크 헤더의 움직임을 최소화하여 작업 시간과 리소스 점유 비용을 줄일 수 있음

\- 테이블 풀 스캔일 때는 인접한 페이지를 여러 개 읽는 다중 페이지 읽기 방식으로 수행

페이지 읽는 순서 : 1 → 2 → 3 → 4 → 5 → 6 → 7

![image](https://github.com/Hju95/database-study/assets/59231743/081b9a8e-05ae-4edb-a057-331b641acf9f)

| 랜덤 액세스 |

\- 페이지의 물리적인 위치를 고려하지 않고, 임의의 페이지에 직접 접근하는 방식

\- 페이지에 디스크 헤더가 물리적으로 이동하면서 데이터에 접근하므로, 데이터 접근에 많은 시간이 소요됨

페이지 읽는 순서 : 1 → 6 → 3 → 7 → 5 → 2 → 4 

![image](https://github.com/Hju95/database-study/assets/59231743/04dfe3dd-a7d7-479b-8267-644ee63b36e8)

**조건 유형**

-   SQL 문의 WHERE 절 조건문 기준으로 데이터가 저장된 디스크에 접근
-   필요한 데이터에 액세스하는 조건문으로 데이터를 가져오고, 가져온 데이터에서 다시 한번 출력할 데이터만 추출
-   액세스 조건 : 맨 처음 디스크에서 데이터를 검색하는 조건
-   필터 조건 : 디스크에서 가져온 데이터에서 추가로 추출하거나 가공 및 연산하는 조건

| 액세스 조건 |

\- 디스크에 있는 데이터에 어떻게 접근할 것인지를 다루는 액세스 조건(access condition)은 SQL 튜닝에서 가장 중요한 핵심 사항

\- 옵티마이저는 WHERE 절의 특정 조건문을 이용해 소량의 데이터를 가져오고, 인덱스를 통해 시간 낭비를 줄이는 조건절을 선택하여, 스토리지 엔진의 데이터에 접근하고 MYSQL 엔진으로 데이터를 가져옴 

![image](https://github.com/Hju95/database-study/assets/59231743/4f4f886b-2f87-4a2c-9f92-b8c51320fbb4)

| 필터 조건 |

\- 액세스 조건을 이용해 MySQL 엔진으로 가져온 데이터를 기준으로 추가로 불필요한 데이터를 제거하거나 가공하는 조건

\- 필터 조건에 따라 필터링할 데이터가 없다면 매우 훌륭한 SQL문이고, 필터 조건으로 필터링되어 제거된 데이터가 다수 존재한다면 상대적으로 비효율적인 SQL문

\-> 스토리지 엔진에서 MYSQL 엔진으로 데이터를 전달하는 오버헤드가 있으며, 필터 조건으로 제거될 데이터라면 스토리지 엔진의 데이터에 접근하는 과정에서 같이 제외되는 편이 성능적으로 효율적이기 때문

\- 이때 필터 조건으로 제거되는 데이터 비율을 확인하고 SQL 튜닝이 필요한지 판단 가능  
\-> 실행 계획의 filtered 항목에서 확인 가능

![image](https://github.com/Hju95/database-study/assets/59231743/593afe85-0692-42da-b137-f147a4b19e0b)

#### 2.3.2 응용 용어

**선택도**

\- 테이블의 특정 열을 기준으로 해당 열의 조건절(WHERE절 조건문)에 따라 선택되는 데이터 비율을 의미

\- '선택도가 높다' 는 해당 열에 중복되는 데이터가 많다라는 의미

\- '선택도가 낮다' 는 해당 열에 중복되는 데이터가 적다라는 의미

\- 낮은 선택도가 대용령 데이터에서 원하는 데이터만 골라내는 능력이라고 볼 수 있음  
\-> 낮은 선택도를 가지는 열은 데이터를 조회하는 SQL 문에서 원하는 데이터를 빨리 찾기 위한 인덱스 열을 생성할 때 주요 고려대상

![image](https://github.com/Hju95/database-study/assets/59231743/9430aca9-3780-4c43-9a4d-e9a28a1012fb)

-   선택도 계산식

데이터에 접근하고자 특정 열에 대한 조건문을 작성하고, 해당 조건문에 포함되는 열의 선택도를 산출

> 선택도 = 선택한 데이터 건수 / 전체 데이터 건수

선택하는 조건절의 데이터 건수를 매번 계산할 수 없고, 데이터의 삭제와 수정, 삽입이 수시로 발생하는 만큼 중복이 제거된 데이터 건수를 활용하여 선택도를 일반화

> 변형된 선택도 = 1 / DISTICT(COUNT 열명)

**카디널리티**

\- 하나의 데이터 유형으로 정의되는 데이터 행의 개수

\- 전체 데이터에 접근한 뒤 출력될 것이라 예상되는 데이터 건수

\- 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표

-   카디널리티 계산식

> 카디널리티 = 전체 데이터 건수 x 선택도

전체 데이터 100건에서 기본 키가 학번인 열을 대상으로 카디널리티를 계산한다고 가정

100 x 0.01 = 1건 -> 모든 학번의 데이터 값이 고유한 만큼 1건의 데이터만 출력되리라 예측

-   MySQL 카디널리티 계산 방식

\- 중복을 제외한 유일한 데이터값의 수로 계산

\- 특정 열에 중복된 값이 많다면 카디널리티가 낮다고 할 수 있으며, 해당 열을 조회하면 상당수의 데이터를 거르지 못한 채 대량의 데이터가 출력되리라 예측할 수 있음

![image](https://github.com/Hju95/database-study/assets/59231743/c7a82d8a-4282-4ed5-8129-94860ccbc6b1)

왼쪽 그림에는 중복되는 2개의 도형만 있고, 일부 도형을 선택하더라도 중복된 도형임을 확인할 수 있으므로 카디널리티가 낮다고 평가

오른쪽 그림에는 동일한 도형이 없고, 일부 도형을 선택하더라도 매번 다른 패턴의 도형이 확인되므로 카디널리티가 높다고 평가

-   중복도 ▲ 카디널리티 ▼
-   중복도 ▼ 카디널리티 ▲

-----
> TIP 일상생활에서의 카디널리티 적용 사례

-   주민등록번호 : 카디널리티 높음
-   이름 : 카디널리티 중간
-   성별 : 카디널리티 낮음

-----
**힌트**

\- 데이터를 빨리 찾을 수 있게 추가 정보를 전달하는 것

![image](https://github.com/Hju95/database-study/assets/59231743/42f6fcfb-f89d-4041-8365-72f04a950dc4)

```
-- 힌트 주석 표시
SELECT 학번, 전공코드
  FROM 학생 /*! USE INDEX (학생_IDX01) */
 WHERE 이름 = '유재석';
 
 -- 힌트 주석 표기 없이
 SELECT 학번, 전공코드
  FROM 학생 USE INDEX (학생_IDX01)
 WHERE 이름 = '유재석';
```

| 힌트 | 설명 | 활용도 |
| --- | --- | --- |
| STRAIGHT\_JOIN | FROM 절에 작성된 테이블 순으로 조인을 유도하는 힌트 | 높음 |
| USE INDEX | 특정 인덱스를 사용하도록 유도하는 힌트 | 높음 |
| FORCE INDEX | 특정 인덱스를 사용하도록 강하게 유도하는 힌트 | 낮음 |
| IGNORE INDEX | 특정 인덱스를 사용하지 못하도록 유도하는 힌트 | 중간 |

-----
> TIP 강력하지 않은 힌트

명시적으로 힌트를 작성해도 옵티마이저는 무조건 힌트를 참고하지 않음

옵티마이저가 비효율적이라고 예측하면 사용자가 작성한 힌트는 무시될 수 있음

-----
-----
> TIP 힌트 사용 시 고려사항

힌트가 적용된 서비스 환경에서는 데이터 건수가 수시로 급변할 수 있고, 테이블이나 인덱스/뷰 등에 변화가 생기면 SQL 문 실행 시 오류가 발생할 가능성도 있음

이때는 SQL 문에 힌트를 작성하면 별도로 관리해야함

**인덱스 사용 -> 인덱스 삭제 -> 인덱스 사용했던 SQL 문을 실행하지 못하고 오류 메세지를 출력**

MySQL/MariaDB 에서는 작성된 힌트의 오브젝트가 존재하지 않으면 에러 발생

오라클은 힌트가 부적절하게 작성되었거나 존재하지 않는 오브젝트를 명시하더라도 해당 힌트를 무시하고 SQL 문 실행

-----

**콜레이션**

\- 특정 문자셋으로 데이터베이스에 저장된 값을 비교하거나 정렬하는 작업의 규칙을 의미

-   소문자 a 와 대문자 A 중에 무엇이 더 클까요?
-   소문자 a 와 소문자 b 중에 무엇이 더 클까요?

| utf8\_bin | utf8\_general\_ci |
| --- | --- |
| A | A |
| B | a |
| a | B |
| b | b |

\- 데이터베이스 단위, 테이블 단위, 열 단위까지 세세하게 설정 가능

-----
> TIP 캐릭터셋 vs 콜레이션

데이터를 저장하는 방식에 대한 캐릭터셋과 데이터 정렬에 대한 콜레이션을 다음과 같이 간단히 비교

| 캐릭터셋(character set) | 콜레이션(collation) |
| --- | --- |
| 데이터 저장을 어떻게 할 것인가   \- 영문 + 숫자   \- 중국어   \- 다국어   \- 예) utf8(다국), utf8mb4(다국어 + 이모지) | 데이터 정렬은 어떻게 할 것인가   \- a 와 A 간의 대소 관계 정의   \- a 와 b 간의 대소 관계 정의   ...   \- 예) utf8\_general\_ci, utf8\_bin (다국어 + 이모지) |

-----
**통계정보**

\- 옵티마이저는 통계정보에 기반을 두고 SQL 문의 실행 계획을 수립

\- MySQL 은 시스템 변수를 통해 활용할 통계정보의 수준을 정의

\- 통계정보의 최신성 유지 및 관리가 매우 중요

**히스토그램**

\- 테이블의 열값이 어떻게 분포되어 있는지를 확인하는 통계정보

\- 옵티마이저가 실행 계획을 최적화하고자 참고하는 정보로, 잘못된 히스토그램 정보가 있다면 잘못된 실행 계획으로 SQL 문이 실행될 수 있음

\- 특정 열값들의 통계정보가 히스토그램으로 수집되지 않았다면, 중복이 제거된 열값의 개수(COUNT(DISTINCT 열명)) 로 대략적인 열갑의 분포를 예측하고 실행 계획을 수립

\- MySQL에서 내부적으로 열의 분포를 저장할 때는 높이균형 히스토그램 방식을 사용

\- 즉, 저장된 데이터값의 종류가 수백, 수천, 수만 개 이상이므로 이 데이터 값들을 그룹화하고, 정해진 양동이(=버킷) 만큼 분리해서 열의 통계정보 데이터를 저장

![image](https://github.com/Hju95/database-study/assets/59231743/127e1ccc-59e0-4234-9c8f-4c2ea41a0662)

-   실제 데이터베이스에서 관리하는 히스토그램의 버킷은 최댓값만 보관
-   버킷1 = AAA, 버킷2 = EE, 버킷3 = H, 버킷 4 = JJJ, ..., 버킷 10 = ZZZ
-   만약, WHERE 절 조건문에 Col1 = 'A' → 버킷 1에만 접근하여 데이터 분포 파악
-   Col1 BETWEEN E AND O → 버킷 2부터 6까지 총 5개 버킷에 접근(전체 데이터 대비 50% 이상의 영역을 스캔해야 하므로 인덱스 스캔보다 테이블 풀 스캔으로 쿼리가 수행되도록 통계정보를 제공)

-----
> TIP 히스토리 정보 직접 생성하기

MySQL

```
-- 문법
ANALYZE TABLE 테이블명 UPDATE HISTOGRAM ON 열명 나열;

-- 예시
ANALYZE TABLE 사원 UPDATE HISTOGRAM ON 이름;

-- 확인
SELECT * FROM INFORMATION_SCHEMA.COLUMN_STATISTICS; 를 통해서 결과 확인
```

MariaDB

```
-- 문법
ANALYZE TABLE 테이블명 PERSISTENT FOR COLUMNS (열명 나열) INDEXS(인덱스명 나열);

-- 예시
ANALYZE TABLE 사원 PERSISTENT FOR COLUMNS (사원번호, 이름) INDEXED();

-- 확인
SELECT * FROM mysql. colum_stats; 를 통해서 결과 확인
```
-----
