# 목차

- 물리 엔진과 오브젝트 용어
	- DB 엔진 용어
	- 프로세스 용어
	- 오브젝트 용어
- 논리적인 개념 용어 
	- 서브쿼리 위치에 따른 SQL 용어
	- 메인쿼리와의 관계성에 따른 SQL 용어
	- 반환 결과에 따른 SQL 용어ƒ
	- 조인 연산방식 용어
	- 조인 알고리즘 용어
- 개념적인 튜닝 용어
	- 기초 용어
	- 응용 용어
- 마치며

---
# 물리 엔진과 오브젝트 용어

## DB엔진 용어

사용자는 DB에서 원하는 데이터를 가져오기 위해 SQL 문을 실행한다. 이때 실행된 SQL문은 다양한 문법 및 구문으로 검사, 효율적으로 찾아가는 전략을 수립합니다. 이러한 일련의 과정은 다음 그림으로 나타낼 수 있습니다.

![[Pasted image 20240129204907.png]]

### 스토리지 엔진

InnoDB, MyISAM, Memory와 같은 스토리지 엔진은 사용자가 요청한 SQL문을 토대로 DB에 저장된 메모리에서 필요한 데이터를 가져오는 역할을 수행한다. 이후 MySQL 엔진으로 보내준다.

대부분은 InnoDB 엔진을 사용하며, 대량의 쓰기 트랜잭션은 MyISAM, 데이터를 빠르게 읽는 효과를 내려면 Memory엔진을 사용할  수 있어 용도에 맞게 선택하여 사용 가능하다.

### MySQL 엔진

사용자가 요청한 SQL 문을 넘겨받은 뒤 문법 검사, 적절한 오브젝트 활용 검사, SQL문을 최소 단위로 분리하여 최적화 해주는 역할이다. 

즉, SQL문의 시작과 끝에 관여하여 필요한 데이터만을 가져오는 핵심 역할을 담당

---
## SQL 프로세스 용어

### SQL 프로세스

1. 사용자가 SQL 문을 실행하면  MySQL이 이해할 수 있는 최소 단위로 구성요소를 분리하여 트리로 만듭니다. 트리를 구성하는 과정에서 문법 오류 검토 및 키워드로 분리합니다. (에러 발생시 즉시 종료)
2. 생성된 트리 결과를 토대로 이미 만들어져 있는지, 뷰로 구성되었는지, 권환 검사 등의 유효성을 검증합니다. (에러 발생시 사용자에게 표시)
3. 검증된 트리의 데이터를 효율적으로 가져오기 위해 실행 계획을 수립합니다. 수립한 계획을 가지고 스토리지 엔진을 호출해 필요한 데이터를 가져옵니다.
4. 스토리지 엔진을 통해 가져온 데이터 중 불필요한 데이터를 필터링 하여 사용자가 원하는 결과를 전달

![[Pasted image 20240129210928.png]]

### Parsor

MySQL 엔진에 포함되는 오브젝트로 사용자가 욫어한 SQL문을 쪼개 최소 단위로 분리 후 트리를 만들면서 문법 검사를 수행한다.

### Preprocessor

MySQL의 엔진에 해당 되는 오브젝트로 Parsor에서 생성한 트리의 구조적인 문제가 없는지 파악한다. SQL 문의 Table, Column, Func, View와 같은 오브젝트의 유효성을 검사한다.

### Optimizer

MySQL의 핵심 엔진 중 전달된 파서 트리를 토대로 필요하지 않은 조건은 제거하거나 연산 과정을 단순화 한다. 또한 실행 계획이라는 것을 수립하는데 이것은 최상의 실행 계획이 아닌 최적의 실행 계획이라는 것이다.

실행 계획을 수립하는 과정 또한 리소스이며 항상 최적의 실행은 아니기 때문에 적절히 다루어야한다.

### Engine executor

MySQL 엔진과 스토리지 엔진 영역에 모두 걸치는 오브젝트로, Optimizer에서 수립한 계획을 토대로 Storage engine에서 데이터를 가져온다. 이후 데이터 정렬 및 조인, 불필요한 데이터 삭제와 같은 추가 작업을 담당한다.

MySQL의 부하는 추가 작업을 최소화 하는 것과, storage에서 가져오는 데이터를 줄이는 것이 매우 중요하다.

---
### 오브젝트 용어

데이터베이스를 구성하는 요소 중 하나로 오브젝트라고 불림

- Table : 데이터를 저장하는 오브젝트이며 row, column의 정보를 담는다.
- Row : 테이블에서 동일한 구조의 데이터 항목들의 집합 
- Column : 사전에 정의한 데이터 유형
- Primary key : 특정 column을 대표하는 값
- Foreign key : 외부의 있는 테이블을 참조하며, 외부 테이블의 데이터가 변경되면 영향을 받는 관계를 설정하는 값
- index : unique index, non-unique index로 나뉘며 데이터베이스에서 키값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는 키를 기준으로 정렬된 오브젝트
- view : 물리적으로 잡히지 않는 가상 테이블이며 외부의 직접적으로 공개하지 않고 제한적인 정보만 제공하며 변경도 가능해 마치 테이블인 것처럼 활용 가능

---
# 논리적인 SQL 개념 용어

### 서브쿼리

쿼리 안의 보조쿼리를 가르키는 용어이며 어디에 작성되었는지에 따라 명칭이 달라진다.

select : 스칼라 서브쿼리
from : 인라인 뷰
where : 중첩 서브쿼리

### 스칼라 서브쿼리

select 절에 있는 또 다른 select절이다. 메인쿼리의 select절에는 최종 출력하기 위한 열들이 나열되므로, 출력 데이터 1건과 같은 결과가 나와야 한다. 

보통 데이터 건수가 1건이므로 집계합수(max, min, avg, sum, count)가 자주 사용된다.

```sql
select 이름, (select count(*) 
			from 학생 as 학생2
			where 학생2.이름 = 학생1.이름 ) 카운트
	from 학생 as 학생;
```
??이게 뭐누

### 인라인 뷰

from 절에 사용되는 서브쿼리를 의미하며 일시적으로 뷰를 생성하는 방식이므로 인라인 뷰가 칭한다.

인라인 뷰의 결과는 내부적으로 메모리에 임시 테이블을 생성하여 활용

```sql
select 학생2.학번, 학생2.이름
from (select * 
	  from 학생
	  where 성별 = '남') 학생2;
```

### 중첩 서브쿼리

where절에 있는 서브쿼리이며 단순한 값 비교 연산 대신 서브쿼리를 추가하여 중첩 서브쿼리라고 불림

일반적으로 비교 연산자를 비롭해 in, exists, not in, not exists 문을 많이 사용한다.

```sql
select *
from 학생
where 학변 = (select max(학번)
		   from 학생)
```


### 비상관 서브쿼리

서브쿼리와 메인쿼리가 관계가 없다는 의미이다. 즉, 서브쿼리가 독자적으로 실행한 후 메인쿼리에게 결과를 던져주는 형태

서브쿼리 실행 -> 메인 쿼리 실행

### 상관 서브쿼리

서브쿼리와 메인쿼리가 관계성이 있다는 의미이다. 서브쿼리가 수행되려면 메인쿼리의 값을 받아야 하므로 관계성이 존재한다. 

상관 서브쿼리는 스칼라 서브쿼리, 중첩 서브쿼리일 때 발생할 수 있다.

메인 -> 서브 -> 메인으로 수행순서가 진행되기 때문에 옵티마이저에 따라 SQL 재작성이 작동할 수있습니다.

### 단일행 서브쿼리

서브쿼리 결과가 1건의 행으로 반환되는 쿼리이며 메인쿼리의 조건절에서는 연산자와 비교합니다. 스칼라 서브쿼리와 동일하다고 볼 수 있다.

### 다중행 서브쿼리

서브쿼리의 결과가 여러 건의 행으로 반환되는 쿼리이며 메인쿼리의 조건절에서는 IN 구문으로 서브쿼리에서 반환되는 값을 받는다.

### 다중열 서브쿼리

서브쿼리의 결과가 여러 개의 열과 행으로 반환된다. 메인쿼리의 조건절에서는 IN 구문과 함께 서브쿼리에서 반환될 열들을 동일하게 나열해 결과를 받는다.

---
## 조인

분리된 데이터 간의 공통의 정보를 가지고 필요한 데이터끼리 결합할 때 조인이라는 방식을 사용한다.
즉, 동일한 키값 기준으로 데이터를 논리적으로 연결할 목적

inner join : 교집한에 해당하는 방식으로 양쪽에 모두 존재하는 데이터만 반환
left outer join : 왼쪽 테이블 기준으로 오른쪽 테이블과 조인을 수행하지만 조건과 일치하지 않아도 왼쪽 결과에 포함
right outer join : 위와 동일한 개념
cross join : 곱집합의 개념으로 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 찾아 반환
natural join : 공통의 정보가 있다면 inner join, 하나도 없다면 cross join -> 굳이 써야되나?

---

## 조인 알고리즘

다수의 테이블에 조인을 수행할 때 동시에 접근이 불가하기 때문에 우선순위를 정해야한다. 이 때 접근하는 선후 관계에 따라 드라이빙 테이블, 드리븐 테이블이라는 용어로 구별한다.

inner join을 한다는 가정을 했을 때 드리븐 테이블에 접근할 데이터가 적을 수록 성능에 도움이 되기 때문에 드라이븐 테이블의 데이터가 적을 수록 좋다.

### 중첩 루프 조인

드라이빙의 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 공통된 데이터를 출력하는 방식

이중 포문과 동일한 방법

### 블록 중첩 루프 조인

중첩 루프 조인의 효율성을 높이고자 탄생하였으며 조인 버퍼라는 개념을 도입하여 성능 향상을 목적으로 한 알고리즘

중첩 루프 조인과 동일한 방식으로 동작하지만 바로 드리븐 테이블에 접근하는 것이 아닌 조인 버퍼라는 곳에 데이터를 적재한다. 조인 버퍼의 용량이 전부 채워지면 한번에 드리븐 테이블과 비교하여 중첩 루프 조인보다 효율적으로 검색을 수행한다.

### 배치 키 액세스 조인?  이해가 안감


### 해시 조인

조인의 참여하는 각 테이블의 데이터를 내부적으로 해시값을 만들어 내부 조인을 수행한 결과를 조인 버퍼에 저장한다.

즉, 서로 다른 테이블의 해시값을 비교하여 일치한 경우만 조인 버퍼에 저장한다.

---
# 튜닝 용어

오브젝트를 스캔하는 유형, 디스크 접근 방식과 같은 쿼리 튜닝과 관련된 용어

## 오브젝트 스캔 유형

테이블 스캔과 인덱스 스캔으로 구분된다. 테이블 스캔은 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근하는 유형이며, 인덱스 스캔은 테이블 데이터를 찾아가는 유형이다.

### 테이블 풀 스캔

인덱스를 거치지 않고 테이블로 바로 직행하여 처음 부터 끝까지 데이터를 훑는 방식이며 인덱스 없이 스캔하는 유일한 방법 -> 걍 포문

### 인덱스 범위 스캔

인덱스를 범위 기준으로 스캔한 뒤 스캔 결과를 토대로 테이블의 데이터를 찾아가는 방식. SQL 구문에서 between, and, like, >, < 와 같은 비교 연산 구문에 포함될 경우 인덱스 범위 스캔으로 수행한다.

좁은 범위를 스캔할 때는 효과적이지만 넓은 범위를 스캔할 때는 비효율적이다.

### 인덱스 풀 스캔

인덱스를 처음부터 끝까지 수행하는 방식. 테이블 풀 스캔보다는 인덱스가 상대적으로 양이 적어 성능적으로 좋지만 이럴꺼면 인덱스 안쓰지

### 인덱스 고유 스캔

기본키 또는 유니크 인덱스로 테이블에 접근하는 방식으로 인덱스 스캔 방식 중 가장 효율적이다. where = 조건으로 작성하며, 해당 조인 열이 기본키 또는 고유 인덱스의 선두열로 설정되었을 때 활용 -> (key,value)

### 인덱스 루스 스캔??

인덱스의 필요한 부분들만 골라 스캔하는 방식 where절 조건문 기준 필요한 데이터와 필요하지 않은 데이터를 구분한 뒤 불필요한 인덱스 키는 무시한다.

group by, max, min 메서드가 포함되면 작동한다.

### 인덱스 병합 스캔?

테이블 내에 생성된 인덱스들을 통합해서 스캔하는 방식 where절 문의 조건이 서로 다른 인덱스로 존재하면 동일한 옵티마이저가 인덱스를 모두 가져와서 활용하는 방식 -> 예시가 뭐가 있지??

## 디스크 접근 방식

MySQL은 데이터가 저장된 스토리지의 페이지(검색하는 최소단위)에 접근한다. 서로 연결된 페이지를 순차적으로 읽는 방법에 시퀀셜 액세스, 임의로 열어보며 데이터를 읽는 랜덤 엑세스 방식이 있다.

### 시퀀셜 액세스

페이지를 차례대로 읽는 순차 접근 방식으로, 데이터를 찾고자 이동하는 디스크 헤더의 움직임을 최소화하여 작업 시간과 리소스 점유 비용을 줄일 수 있다.

### 랜덤 액세스

물리적으로 떨어진 페이지들에 임의로 접근하는 방식으로 물리적 위치를 고려하지 않고 접근하여 데이터의 접근 수행 시간이 오래 걸린다. 따라서 접근 범위를 줄이고 효율적인 인덱스 활용을 하기 위한 튜닝이 필수적이다.
