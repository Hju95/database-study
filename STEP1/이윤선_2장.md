# 2.1. 물리 엔진과 오브젝트 용어

# 2.1.1. DB 엔진 용어

---

## 스토리지 엔진

- **역할 :** 스토리지엔진(InnoDB, MyISAM, Memory 등)은 사용자가 요청한 SQL로 DB에 저장된 디스크나 메모리에 필요한 데이터를 가져온다.
- **선택 기준 :** 데이터를 저장하는 방식에 따라 각각의 스토리지 엔진을 선택해서 사용한다.
    - InnoDB : 데이터 일관성과 안정성이 중요한 OLTP(online transaction processing) 환경에서 사용.
    일반적으로 온라인상의 트랜잭션 발생으로 데이터를 처리하는 OLTP 환경이 대다수이기 때문에 InnoDB를 자주 사용한다.
    - MyISAM : 대량의 쓰기 트랜잭션이 발생할 때 사용
    - Memory : 메모리 데이터를 로드해서 빠르게 데이터를 읽어야할 경우 사용

## MySQL 엔진

- **역할 :** 사용자가 요청한 SQL에 대한 문법검사, 적절한 오브젝트 활용 검사를 하고 SQL을 최소 단위로 분리하여 원하는 데이터를 빠르게 찾는 경로를 모색 → 스토리지 엔진 엔진으로부터 받은 데이터에서 불필요한 데이터를 제거하거나 가공 및 연산한다.
- 즉, SQL 문의 시작과 마무리 단계에서 MySQL 엔진이 관여하며, 스토리지 엔진으로 부터 필요한 데이터만을 가져오는 역할을 담당한다.

<img src="https://github.com/yoonseon12/database-study/assets/59242594/baef69f1-98c4-4000-938b-6d91977ed689" width="300" height="300">


# 2.1.2. SQL 프로세스 용어

---

### 파서

- 사용자가 요청한 SQL을 최소 단위로 분리하고 트리로 만든다. 트리를 만들면서 문법 검사를 수행한다.

### 전처리기

- 파서에서 생성한 트리를 토대로 SQL문에 작성된 테이블, 열, 함수, 뷰와 같은 오브젝트가 실질적으로 존재하는지, 접근 권한은 부여되어 있는지 확인하는 역할을한다.

### 옵티마이저

- 전달된 파서 트리를 기반으로 옵티마이저는 불필요한 조건 제거 및 연산 단순화를 수행하고, 효율적인 테이블 접근 순서, 인덱스 선택, 정렬 시 임시 테이블 사용 등 핵심적인 최적화 역할을 담당한다.
- 실행 계획이 많을 때 옵티마이저는 모든 경우를 판단하지 않고, 비용을 빠르게 산정하여 최적의 실행 계획을 선택한다. → 선택된 계획이 항상 최상의 실행계획 이 아닐 수 있음.

### 엔진 실행기

- 옵티마이저가 수립한 실행 계획을 기반으로 스토리지 엔진에서 데이터를 가져온 후, MySQL 엔진에서 데이터를 정렬, 조인하고 불필요한 데이터를 필터링하는 추가 작업을 수행한다.
- 따라서 MySQL 엔진의 부하를 최소화하려면 스토리지 엔진에서 가져오는 데이터 양을 줄이는 것이 중요하다.

# 2.1.3. DB 오브젝트 용어

---

### 인덱스

- 인덱스는 DB에서 키값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는 키 기준으로 정렬된 오브젝트이다.
    - 기본키(PK)는 클러스형 인덱스로 작동한다.
- 인덱스는 생성하려는 열의 속성에 따라 고유 인덱스와 비고유 인덱스로 구분할 수 있다.

### 고유 인덱스

- 인덱스를 구성하는 열들의 데이터가 유일하다는 의미
- 유니크키를 생성하면 자동으로 유니크 인덱스키를 생성한다.
- 반대로 유니크 인덱스키를 생성하면 유니크키가 생성된다.

> ***기본 키와 고유 인덱스의 차이점***
기본 키와 고유 인덱스 모두 데이터의 유일성을 보장하고 효율적인 데이터 접근을 위한 인덱스 수단으로 사용된다.
하지만 기본 키에는 NULL을 삽입할 수 없고 고유 인덱스에는 NULL 삽입이 가능하다.
> 

### 비 고유 인덱스

- 비 고유 인덱스는 고유 인덱스에서 데이터의 유일한 속성만 제외한 키로 데이터가 신규로 입력되어 인덱스가 재정렬 되어도 인덱스 열의 중복 체크를 거치지 않고 단순한 정렬 작업을 수행한다.

### 뷰

- 하나 이상의 테이블로부터 파생된 가상 테이블로, 저장 공간을 차지하지 않으며 쿼리의 결과를 나타낸다.
뷰는 데이터베이스 사용자에게 데이터의 일부 또는 필요한 부분만을 제공하고, 특정 조건에 따라 데이터를 가공하거나 조인할 수 있으며 데이터의 추상화를 제공하여 복잡한 쿼리를 간소화하고 보안성을 높이는 데 사용된다.
- 뷰 테이블은 항상 원본 테이블을 바라보고 있기 때문에 원본 테이블의 데이터가 변경되면 뷰 테이블도 변경된 데이터를 출력한다.

> ***뷰를 사용하는이유***
일부 데이터에 대해서만 데이터를 공개하고, 노출에 민감한 데이터에 대해서는 제약을 설정할 수 있는 보안성 때문이다. 한편 여러 개의 테이블을 병합해서 활용할 때에는 성능을 고려한 최적화된 뷰를 생성함으로써 일관된 성능을 제공할 수 있다.
> 

# 2.2. 논리적인 SQL 개념 용어

# 2.2.1 서브쿼리 위치에 따른 SQL 용어

---

서브쿼리란 쿼리 안의 보조쿼리를 가르키는 용어다.
메인쿼리를 기준으로 내부에 서브쿼리가 어디에 위치하는지에 따라 부르는 용어가 달라진다.

```sql
SELECT (SELECT ... FROM ...)        -> SELECT 절 : 스칼라 서브쿼리
FROM (SELECT ... FROM ...)          -> FROM 절 : 인라인 뷰
WHERE 컬럼명 IN (SELECT ... FROM ...) -> WHERE절 : 중첩 서브쿼리
```

### 스칼라 서브쿼리

- 서브쿼리가 반환하는 결과가 단일 값을 가지는 경우이다. 즉, 결과 값이 항상 1행 1열의 구조로 출력되어야 한다.
- 메인쿼리 SELECT 절 목록이나 WHERE에 주로 사용된다.
- 출력되는 데이터 건수가 1건이어야 하므로 집계함수가 자주 쓰인다.

```sql
SELECT 이름,
       (SELECT count(*)
          FROM student AS st2
		     WHERE st2.name = st1.name) cnt
  FROM student AS st1
```

### 인라인 뷰

- 메인쿼리의 FROM 절에 있는 또다른 SELECT 절이다.
- FROM 절 내부에서 일시적으로 뷰를 생성하는 방식으로 인라인 뷰라고 불린다.
- 인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성해서 활용한다.

```sql
SELECT st2.number, st2.name
  FROM (SELECT *
          FROM st
         WHERE gender = '남') st2
```

### 중첩 서브쿼리

- 메인쿼리의 WHERE 절에 있는 또 다른 SELECT 절을 중첩 서브쿼리라고 한다.
- WHERE 절에서 단순한 값을 비교 연산하는 대신, 서브쿼리를 추가하여 비교 연산하기 위해 사용한다.
- 보통 연산자나 IN, EXISTS 문을 많이 사용한다.

```sql
SELECT *
  FROM student
 WHERE number = (SELECT MAX(number) FROM student)
```

# 2.2.2. 메인쿼리와의 관계성에 따른 SQL 용어

---

서브쿼리는 그 자체가 독립적인 형태로 존재할 수 있고 메인쿼리와 끈끈한 관계를 유지하며 존재할 수도 있다.

### 비상관 서브쿼리

- 서브쿼리가 독립적으로 실행된 뒤 메인쿼리에게 그 결과를 던저주는 형태이다.
- **서브쿼리 실행 → 메인쿼리 실행**의 순서로 수행된다.
- DB버전 및 옵티마이저에 따라 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병햡, 즉 SQL 재 작성이 작동할 수 있다.

```sql
SELECT *
  FROM student
 WHERE number IN (SELECT * number
                    FROM student
                   WHERE gender = '남')
```

### 상관 서브쿼리

- 서브쿼리가 수행되려면 메인쿼리의 값을 받아야 하므로 서브쿼리와 메인쿼리는 끈끈한 관계를 유지하게 된다.
- **메인쿼리 실행(student.num 가져오기) → 서브쿼리 실행(advisor.num = student.num) 
→ 메인쿼리 실행(SELECT * FROM student ~)**

```sql
SELECT *
  FROM student
 WHERE num IN (SELECT num
                 FROM advisor
                WHERE gender = advisor.num = student.num)
```

# 2.2.3. 반환 결과에 따른 SQL 용어

### 단일행 서브쿼리

- 서브쿼리의 결과과 1건의 행으로 반환

```sql
SELECT ...
  FROM ...
 WHERE num = (SELECT max(num) FROM student)
```

### 다중행 서브쿼리

- 서브쿼리의 결과가 여러 건의 행으로 반환

```sql
SELECT ...
  FROM ...
 WHERE num IN (SELECT max(num) FROM student GROUP BY code)
```

### 다중열 서브쿼리

- 서브쿼리의 결과가 여러개의 행과 열로 반환

```sql
SELECT ...
  FROM ...
 WHERE (name, code) IN (SELECT name, code FROM student where name like '김%')
```

# 2.2.4. 조인 연산방식 용어

### 내부 조인(inner join)

- 교집합 데이터를 반환한다.

<img src="https://github.com/yoonseon12/database-study/assets/59242594/68d55a9d-2fd1-4571-9b40-c827338cd057" width="450" height="300">

**내부조인 - 명시적 조인**

```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
  FROM 학생
  JOIN 지도교수
    ON 학생.학번 = 지도교수.학번
```

**내부조인 - 암시적조인**

```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
  FROM 학생, 지도교수
 WHERE 학생.학번 = 지도교수.학번
```

### 왼쪽 외부 조인(left outer join)

- 왼쪽 테이블 기준 오른쪽 테이블과 조인을 수행하지만, 조인 조건과 일치하지 않아도 왼쪽 테이블의 결과는 모두 반환한다.(조인조건과 일치하지 않는 행은 null)

<img src="https://github.com/yoonseon12/database-study/assets/59242594/b52aa6de-bbe0-4043-8472-70d8ae908666" width="450" height="300">

```sql
SELECT 학생.학번, 지도교수.교수명
  FROM 학생
  LEFT OUTER JOIN 지도교수
    ON 학생.학번 = 지도교수.학번
```

### 오른쪽 외부 조인(right outer join)

- 오른쪽 테이블 기준 왼쪽 테이블과 조인을 수행하지만,조인 조건과 일치하지 않아도 오른쪽 테이블의 결과는 모두 반환한다.(조인조건과 일치하지 않는 행은 null)
- 보통 left outer join을 자주 사용한다.

<img src="https://github.com/yoonseon12/database-study/assets/59242594/874342ed-54ec-4d4a-889d-145de42b665b" width="450" height="300">


```sql
SELECT 학생.학번, 지도교수.교수명
  FROM 학생
  RIGHT OUTER JOIN 지도교수
    ON 학생.학번 = 지도교수.학번
```

### 교차 조인

- 수학적 관점에서 봤을 때 데카트르 곱 이라고 하는 곱집합 개념
- 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 찾아내서 반환한다.
- 모든 경우의 수가 출력 대상이므로 조인 연산과정에서의 시간적, 공간적 리소스 점유 측면에서 오버헤드가 발생하는 만큼 주의해야한다.

<img src="https://github.com/yoonseon12/database-study/assets/59242594/848e829a-dbd2-47c1-8c8d-16984600386d" width="450" height="300">


```sql
SELECT 학생.학번, 지도교수.교수명
  FROM 학생
 CROSS JOIN 지도교수
```

### 자연 조인

- 2개 테이블에 동일한 열명이 있을 때 조인 조건절을 따로 작성하지 않아도 자동으로 조인을 수행하는 방식
- 조인이 제대로 성사되면 내부 조인과 동일한 결과가 출력된다.
    - 조인하는 열의 데이터 유형이 다르더라도 자연 조인이 수행됨

```sql
SELECT 학생.*, 지도교수.*
  FROM 학생
NATURAL JOIN 지도교수
```

- 2개 테이블에 공통으로 존재하는 열명이 없다면?
    - 발생 가능한 경우의 수를 모두 조합하는 교차조인으로 수행된다.
    - 따라서 자연 조인은 열명 변경에 따라 출력 결과가 달라지기 때문에 의도치 않은 결과가 출력될 가능성이 높아 잘 사용하지 않는다.

# 2.2.5. 조인 알고리즘 용어

---

### 드라이빙 테이블과 드리븐 테이블

테이블을 조인할 때, 테이블에 동시 접근할 수는 없으므로 데이터에 접근하는 우선순위가 존재한다.

- 드라이빙 테이블(=outer table) : 먼저 접근하는 테이블
- 드리븐 테이블(=inner table) : 드라이빙 테이블의 검색 결과를 통해 데이터를 검색하는 테이블

드라이빙 테이블에서 많은 건수가 반환되면 해당 결과를 가지고 드리븐 테이블에 접근하게 되기 때문에 적은 결과가 반환될 것으로 예상되는 테이블을 드라이빙 테이블로 설정하고 조인하는 열을 인덱스로 설정하도록 구성해야한다.

### 중첩 루프 조인(NL조인)

- 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 최종적으로 양쪽 테이블에 공통된 데이터를 출력한다.

```sql
SELECT 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
  FROM 학생
  JOIN 비상연락망
    ON 학생.학번 = 비상연락망.학번
 WHERE 학생.학번 IN (1, 100)

# 학생 데이터는 100건
# 비상연락망 데이터는 1000건 이라고 가정한다.
```

✅ **case1 ) 기본키와 인덱스가 없다면?**

1. 학번이 1인 학생을 검색하기 위해 학생 테이블 데이터 100건에 모두 접근, 이후 학번 1과 동일한 데이터를 가진 비상연락망 데이터를 검색하기 위해 비상연락망 데이터 1000건에 모두 접근한다.
2. 학번이 100인 학생을 검색하기위해 학생 테이블 데이터 100건에 모두 접근, 이후 학번 100과 동일한 데이터를 가진 비상연락망 데이터를 검색하기 위해 비상연락망 데이터 1000건에 모두 접근한다.
3. 따라서 총 100 + 1000 + 100 + 1000의 데이터에 접근하게된다.

✅ **case2 ) 학생 테이블의 학번, 비상연락망 테이블의 학번 컬럼이 인덱스로 설정되있다면?**

1. 학번이 1인 학생을 인덱스를 통해 바로 접근하고 비상 연락망 테이블의 학번이 1인 데이터에 바로 접근한다.
2. 학번이 100인 학생을 인덱스를 통해 바로 접근하고 비상 연락망 테이블의 학번이 100인 데이터에 바로 접근한다.
3. 예를 들어 비상연락망의 테이블의 학번이 1, 100인 데이터가 2건씩 있다면 총 1 + 2 + 1 + 2 데이터에 접근하게 된다.

인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 `랜덤 엑세스`가 발생

→ 랜덤 액세스를 줄일수 있도록 데이터의 액세스 범위를 좁혀나가면서 인덱스를 설계하고 조건절을 작성해야함

→ 랜덤 액세스를 유발하는 인덱스는 비고유 인덱스일 때 해당

기본키는 클러스터형 인덱스 이므로 순서대로 테이블에 적재되어있어 조회 효율이 매우 높다!

### 블록 중첩 루프 조인(BNL 조인)

드리븐 테이블의 풀 스캔을 줄이는게 목적으로 성능 저하를 개선하는 조인 알고리즘 방식이다.

- **탄생 배경**
    - 학생 테이블이 드라이빙 테이블이고 비상연락망 테이블은 인덱스가 없다고 가정.
    - 중첩 루프 조인을 한다면 학생 테이블에서 학번 1을 바로 찾은 뒤, 비상연락처 테이블의 모든 데이터에 접근해야할 것임 → 드리븐 테이블을 항상 풀스캔해야함
    - 이러한 경우에 중첩 루프 조인의 효율성을 높이고자 탄생함.
- 드라이빙 테이블에 조인 버퍼(join buffer) 개념을 도입하여 조인 성능을 향상시킨다.
- **수행되는 절차**
    1. 드라이빙 테이블인 학생 테이블에서 학번 1과 100에 해당하는 데이터를 검색한다.
    2. 검색된 데이터를 조인 버터에 가득 채워질 때 까지 적재한다.
        1.  조인 버퍼는 메모리 공간으로, 드리븐 테이블과의 조인을 수행하기 위한 일종의 캐시 역할을 함.
    3. 조인 버퍼와 비상연락망 테이블 데이터를 비교한다.
        1. 이를 통해 드리븐 테이블을 한 번만 풀 스캔하면서 조인을 수행
    4. 조인 버퍼에 적재된 데이터와 드리븐 테이블을 조인을 반복하면서 원하는 데이터를 찾아낸다.
- 이러한 식으로 조인 버퍼의 데이터들과 드리븐 테이블을 한 번의 풀스캔으로 원하는 데이터를 모두 찾을 수 있다. → 드리븐 테이블을 풀 스캔하는 횟수를 최소화하여 성능을 향상

### 배치 키 액세스 조인(BKA 조인)

중첩 루프 조인 방식의 랜덤 액세스 문제를 해결하고자 접근할 데이터를 미리 예상하고 가져오는 데 착안된 조인 알고리즘

- **조인 버퍼 활용 :** 블록 중첩 루프 조인에서 활용한 드라이빙 테이블의 조인 버퍼 개념을 그대로 사용하여 드라이빙 테이블의 조인 키 값을 배치로 가져오고 메모리에 적재한다.
- **랜덤 버퍼의 도입 :** 드리븐 테이블에 필요한 데이터를 미리 예측하고 정렬된 상태로 랜덤 버퍼에 담는다. 이를 통해 드리븐 테이블에 대한 랜덤 액세스가 아닌 시퀀셜 액세스를 수행한다.
    - 다중 범위 읽기(MRR) : 드리븐 테이블의 데이터를 예측하고 정렬된 상태로 버퍼에 적재하는 기능
- **시퀀셜 액세스 수행 :** 랜덤 버퍼에 미리 예측된 데이터가 정렬된 상태로 담겨 있기 때문에 드리븐 테이블에 대한 시퀀셜 액세스를 수행하면서 조인을 효율적으로 진행한다.

### 해시 조인

- MySQL 8.0.18부터 지원
- 선후 관계를 두고 조인을 수행하는 중첩 루프 조인과 달리 조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값을 만들어 내부 조인을 수행한다.
- 해시값으로 내부 조인을 수행한 결과 조인 버퍼에 저장되므로 조인 열의 인덱스를 필수로 요구하지 않는다.

# 2.3. 개념적인 튜닝용어

# 2.3.1. 기초 용어

---

### 오브젝트 스캔 유형

- 테이블 스캔과 인덱스 스캔으로 구분
- 테이블 스캔 : 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근
    - 테이블 풀 스캔
- 인덱스 스캔 : 인덱스로 테이블 데이터에 접근
    - 인덱스 범위 스캔
    - 인덱스 풀 스캔
    - 인덱스 고유 스캔
    - 인덱스 루스 스캔
    - 인덱스 병합 스캔

### 📈 테이블 풀 스캔

- 인덱스를 거치지 않고 테이블에서 바로 처음부터 끝까지 훑는 방식
- WHERE 절의 조건문을 기준으로 활용할 인덱스가 없거나, 전체 데이터 대비 대량의 데이터가 필요할 때 수행된다.
- 성능 측면에서는 부정적이다.
- 인덱스 없이 사용하는 유일한 방식이다.

### 📈 인덱스 범위 스캔

- 인덱스 범위 기준으로 스캔한 뒤 테이블의 데이터를 찾아가는 방식
- SQL문에서 BETWEEN ~ AND 구문이나, <, >, LIKE 구문 등 비교 연산 및 구문에 포함될 경우 인덱스 범위 스캔으로 수행된다.
- 좁은 범위를 스캔할 때는 매우 효율적, 넓은 범위를 스캔할 때는 비효율적인 방식

### 📈 인덱스 풀 스캔

- 인덱스를 처음부터 끝까지 수행하는 방식
- 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 SQL문에서 수행된다.
- 인덱스는 테이블보다 상대적으로 적은 양을 차지하므로 인덱스 풀 스캔 방식이 테이블 풀 스캔보다 성능상 유리하다.
- 인덱스라는 오브젝트의 전 영역을 모두 검색하는 방식인 만큼 검색 범위를 최대한 줄이는 방향으로 SQL 튜닝 해야한다.

### 📈 인덱스 고유 스캔

- 기본키나 고유 인덱스로 테이블에 접근하는 방식
- 인덱스를 사용하는 스캔 방식 중 가장 효율적인 스캔 방법
- WHERE절에 = 조건으로 작성하며, 해당 조인 열이 기본키 또는 고유 인덱스의 선두 열로 설정되었을때 활용된다.

### 📈 인덱스 루스 스캔

- 인덱스의 필요 부분만 골라 스캔하는 방식
- 인덱스 범위 스캔처럼 넓은 범위에 접근하지 않고 WHERE 절 조건문 기준으로 필요한 데이터에만 접근
- GROUP BY 구문이나 MAX(), MIN() 함수가 포함되면 작동한다.
→ 이미 오름차순으로 정렬된 인덱스에서 최댓값이나 최솟값이 필요한 경우 해당된다.

### 📈 인덱스 병합 스캔

- 테이블 내에 생성된 인덱스들을 통합해서 스캔하는 방식
- WHERE 문 조건절의 열들이 서로 다른 인덱스로 존재하면 옵티마이저가 해당하는 인덱스를 가져와 모듀 활용하는 방식을 취한다.
- 통합하는 방법으로는 결합(union), 교차(intersection) 방식이 있으며 이들 방식은 모두 실행 계획으로 출력된다.
- 물리적으로 존재하는 개별 인덱스를 각각 수행하므로 인덱스에 접근하는 시간 소모가 크기 때문에, 일반적으로 여러 개의 별개 인덱스 대신 하나의 인덱스로 통합하거나, SQL문을 변경하여 단일 인덱스만 사용하도록 튜닝한다.

## 디스크 접근 방식

### 💾 시퀀셜 액세스

- 물리적으로 인접한 페이지를 차례대로 읽는 순차 접근 방식으로 보통 테이블 풀 스캔에서 활용한다.
- **주로 사용되는 상황**: 테이블의 전체 데이터를 검색해야 할 때, 또는 범위 검색이 아닌 전체 데이터를 순차적으로 처리해야 할 때 시퀀셜 액세스가 활용
- **디스크 헤더 이동 최소화**: 시퀀셜 액세스는 데이터를 찾고자 하는 디스크 헤더의 이동을 최소화하면서 인접한 페이지를 순차적으로 읽는다.
- **다중 페이지 읽기**: 테이블 풀 스캔 시에는 인접한 페이지를 여러 개 읽는 다중 페이지 읽기 방식(multi-page read)으로 수행되며 이는 성능을 향상시키는데 기여할 수 있음.

### 💾 랜덤 액세스

- 페이지의 물리적인 위치를 고려하지 않고, 임의의 페이지에 직접 접근하는 방식
- **시간 소요**: 페이지에 디스크 헤더가 물리적으로 이동하면서 데이터에 접근하므로, 데이터 접근에 많은 시간이 소요된다.
- **다중 페이지 액세스 어려움**: 랜덤 액세스는 하나의 페이지에 대한 액세스만을 고려하기 때문에 다중 페이지에 대한 효율적인 액세스가 어려울 수 있다.
- **튜닝 필요**: 최소한의 페이지에 접근할 수 있도록 접근 범위를 줄이고, 효율적인 인덱스를 사용하여 랜덤 액세스의 성능을 향상시킬 수 있다.

## 조건 유형

맨 처음 디스크에서 검색하는 조건을 액세스 조건이라고하고, 디스크에서 가져온 데이터를 추가로 추출하거나 가공 및 연산하는 조건을 필터 조인이라고 한다.

### 📌 액세스 조건

- 데이터베이스에서 데이터를 검색할 때, 옵티마이저가 WHERE 절의 특정 조건문을 기반으로 소량의 데이터를 가져오기 위해 선택한 조건
- 이 조건은 주로 인덱스를 활용하여 효율적으로 데이터에 접근할 수 있는지를 결정한다.

### 📌 필터 조건

- 액세스 조건을 이용해 MySQL 엔진으로 가져온 데이터를 기준으로 추가로 불필요한 데이터를 제거하거나 가공하는 조건
- 만약 필터 조건에 따라 필터링할 데이터가 없다면 훌륭한 SQL, 필터 조건으로 제거된 데이터가 다수 존재한다면 비효율적인 SQL이다.
→ 스토리지 엔진에서 MySQL 엔진으로 데이터를 전달하는 오버헤드가 있으며 필터 조건으로 제거될 데이터라면 스토리지 엔진의 데이터에 접근 과정에서 같이 제외되는 편이 성능적으로 효율적이기 때문
- 필터 조건으로 제거되는 데이터의 비율을 확인하고 SQL 튜닝이 필요한지 판단할 수 있따.
    - 해당 비율은 실행 계획의 filtered 항목에서 확인 가능하다.

# 2.3.2. 응용 용어

---

### 선택도

- 테이블의 특정 열을 기준으로 해당 열의 조건절(WHERE절 조건문)에 따라 선택되는 데이터 비율을 의미
- 열에 중복되는 열이 많다면 선택도가 높다고하며, 실제로 조건절에 따라 대량의 데이터가 선택된 것이다.
- 열에 중복되는 열이 적다면 선택도가 낮다고하며, 실제로 조건절에 따라 소량의 데이터가 선택된 것이다.
- 낮은 선택도를 가지는 열은 데이터를 조회하는 SQL에서 원하는 데이터를 빨리 찾기 위한 인덱스 열을 생성할 때 주요 고려 대상이 된다.

**선택도를 계산하는 수식**

```sql
선택도 = 선택한 데이터 건수 / 전체 데이터 건수
```

그러나 매번 선택하는 조건절의 데이터 건수를 계산할 수 없고 삽입 수정이 빈번한 만큼 중복이 제거된 데이터의 건수를 활용하여 선택도를 일반화한다.

```sql
변형된 선택도 = 1 / DISTINCT(COUNT 열명)
```

### 카디널리티

- 하나의 데이터 유형으로 정의되는 데이터 행의 개수
→ 전체 데이터에 접근한 뒤 출력될 것이라 예상되는 데이터 건수
- 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표로 자주 활용한다.

```sql
카디널리티 = 전체 데이터 건수 * 선택도
```

- 특정 열에 중복된 값이 많다면 카디널리티가 낮다고 표현, 해당 열을 조회하면 상당수의 데이터를 거르지 못한 채 대량의 데이터가 출력될 것을 예측할 수 있다.
- 중복도 ⬆️ 카디널리티 ⬇️
- 중복도 ⬇️ 카디널리티 ⬆️

> ***일상 생활에서의 카디널리티 적용 사례***
- 주민등록번호 : 카디널리티 높음 
****- 이름 : 카디널리티 중간
- 성별 : 카디널리티 낮음
> 

### 힌트

데이터를 빨리 찾을 수 있도록 추가 정보를 전달

| 힌트 | 설명 | 활용도 |
| --- | --- | --- |
| STRAIGHT_JOIN | FROM 절에 작성된 테이블 순으로 조인을 유도하는 힌트 | 높음 |
| USE INDEX | 특정 인덱스를 사용하도록 유도하는 힌트 | 높음 |
| FORCE INDEX | 특정 인덱스를 사용하도록 강하게 유도하는 힌트 | 낮음 |
| IGNORE INDEX | 특정 인덱스를 사용하지 못하도록 유도하는 힌트 | 낮음 |

> ***강력하지 않은 힌트란?***
명시적으로 힌트를 작성해도 옵티마이저는 무조건 힌트를 참고하지 않는다. 옵티마이저가 비효율적이라고 예측하면 사용자가 작성한 힌트는 무시될 수 있다.
> 

> ***힌트 사용 시 고려사항***
힌트가 적용된 환경에서는 데이터 건수가 수시로 급변할 수 있고 테이블이나 인덱스/뷰 등에 변화가 생기면 SQL문 실행 시 오류가 발생할 수 있다. 이때는 SQL 문에 힌트를 작성하면 별도로 관리해야한다.
> 

### 콜레이션

특정 문자셋으로 데이터베이스에 저장된 값을 비교하거나 정렬하는 작업의 규칙

- 예시
    - 10 과 11 중 더 큰값은? → 11
    - 2015/11/22와 2016/12/31 중 더 큰 값은? → 2016/12/31
    - a와 A중 더 큰 값은? → ?
    - a와 b중 더 큰 값은? → ?

| utf8_bin | utf8_general_ci |
| --- | --- |
| A | A |
| B | a |
| a | B |
| b | b |
- utf8_bin은 A, B, a, b 순으로 크고 utf8_general_ci는 A, a, B, b 수능로 나타난다.

콜레이션은 데이터베이스 단위, 테이블 단위, 열 단위를 세세하게 설정할 수 있다.

만약 학생 테이블의 콜레이션이 utf8_general_ci로 설정되어 있다면, 학번 열과 전공코드 열에 콜레이션이 명시되어 있지 않아도 utf8_general_ci로 적용된다. 

이 때 열에 utf8_bin을 명시했다면 상위 콜레이션을 무시하고 utf8_bin으로 명시된다.

> ***캐릭터 셋 vs 콜레이션***
캐릭터 셋은 데이터를 어떻게 저장할지 결정
콜리엿ㄴ은 데이터를 어떻게 정렬할지 결정
> 

### 통계 정보

- 옵티마이저가 SQL 실행 계획을 수립할 때 사용하는 데이터베이스 통계에 기반한 정보
- MySQL은 시스템 변수를 통해 활용할 통계정보의 수준을 정의할 수 있다.
- 기본적으로 통계정보에는 다음과 같은 내용이 포함될 수 있다.
→ 따라서 통계정보의 최신성 유지 및 관리가 매우 중요
    1. **테이블 통계 정보**: 테이블의 레코드 개수, 인덱스의 크기 등과 같은 테이블 전체에 대한 정보
    2. **인덱스 통계 정보**: 인덱스의 카디널리티, 특정 값이나 범위에 대한 인덱스의 분포 등과 같은 인덱스에 대한 정보
    3. **열 통계 정보**: 특정 열의 값의 분포, 중복도 등과 같은 열에 대한 정보

### 히스토그램

- 테이블의 열값이 어떻게 분포되어 있는지 확인하는 통계정보로 옵티마이저가 실행 계획을 최적화하고자 참고하는 정보
- 잘못된 히스토그램 정보가 있다면 잘못된 실행계획으로 SQL이 수행될 수 있다.
- 만약 특정 열값들의 통계정보가 히스토그램으로 수집되지 않았다면 중복이 제거된 열값의 개수로 대략적인 열 값은 분포를 예측하고 실행 계획을 수립한다.
